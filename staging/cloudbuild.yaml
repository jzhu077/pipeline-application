steps:
- name: 'gcr.io/cloud-builders/docker'
  args:
    - 'build'
    - '-t'
    - 'gcr.io/${PROJECT_ID}/pipeline-application:${COMMIT_SHA}'
    - '.'
- name: 'gcr.io/cloud-builders/docker'
  args:
    - 'push'
    - 'gcr.io/${PROJECT_ID}/pipeline-application:${COMMIT_SHA}'

# Generate a kubeconfig file for the cluster identified by
# ${_CLOUDSDK_CONTAINER_CLUSTER} in the zone identified by
# ${_CLOUDSDK_COMPUTE_ZONE}.
#
# The generated kubeconfig file is written to /kube/config. Subsequent
# steps can use the kubeconfig by setting the following:
#
#  env:
#    - 'KUBECONFIG=/kube/config'
#
#  volumes:
#    - name: 'kube'
#      path: /kube
#
- name: 'gcr.io/cloud-builders/gcloud'
  env:
    - 'CLOUDSDK_COMPUTE_ZONE=${_CLOUDSDK_COMPUTE_ZONE}'
    - 'CLOUDSDK_CONTAINER_CLUSTER=${_CLOUDSDK_CONTAINER_CLUSTER}'
    - 'KUBECONFIG=/kube/config'
  entrypoint: 'sh'
  args:
    - '-c'
    - |
      CLUSTER=$$(gcloud config get-value container/cluster)
      PROJECT=$$(gcloud config get-value core/project)
      ZONE=$$(gcloud config get-value compute/zone)
      
      cat <<EOF
      Running: gcloud container clusters get-credentials "$${CLUSTER}" --project "$${PROJECT}" --zone "$${ZONE}"
      EOF

      gcloud container clusters get-credentials "$${CLUSTER}" \
        --project "$${PROJECT}" \
        --zone "$${ZONE}"
  volumes:
    - name: 'kube'
      path: /kube

# Ensure a namespace exists for each branch.
- name: 'gcr.io/cloud-builders/gcloud'
  env:
    - 'KUBECONFIG=/kube/config'
  entrypoint: 'sh'
  args:
    - '-c'
    - |
      cat <<EOF | kubectl apply -f -
      kind: Namespace
      apiVersion: v1
      metadata:
        name: ${BRANCH_NAME}
      EOF
  volumes:
    - name: 'kube'
      path: /kube

# Retrieve the encrypted SSH private key and known hosts file from GCS bucket 
# identified by ${_BUCKET}.
#
# The SSH private key and known hosts file are stored under the /root/.ssh
# directory.
#
- name: gcr.io/cloud-builders/gsutil
  args:
    - 'cp'
    - 'gs://${_BUCKET}/pipeline/known_hosts'
    - 'gs://${_BUCKET}/pipeline/pipeline_id_rsa.enc'
    - '/root/.ssh'
  volumes:
    - name: 'ssh'
      path: /root/.ssh

# Decrypt the GitHub SSH private key.
- name: 'gcr.io/cloud-builders/gcloud'
  args:
    - kms
    - decrypt
    - --ciphertext-file=/root/.ssh/pipeline_id_rsa.enc
    - --plaintext-file=/root/.ssh/id_rsa
    - --location=global
    - --keyring=pipeline
    - --key=github
  volumes:
    - name: 'ssh'
      path: /root/.ssh

# Generate an SSH config file.
- name: 'gcr.io/cloud-builders/gcloud'
  entrypoint: 'sh'
  args:
    - '-c'
    - |
      chmod 600 /root/.ssh/id_rsa
      cat <<EOF >/root/.ssh/config
      Hostname github.com
      IdentityFile /root/.ssh/id_rsa
      EOF
  volumes:
    - name: 'ssh'
      path: /root/.ssh

# Clone the pipeline-infrastructure repo which holds the Kubernetes
# deployment manifests.
- name: 'gcr.io/cloud-builders/git'
  args:
    - clone
    - git@github.com:kelseyhightower/pipeline-infrastructure
  volumes:
    - name: 'ssh'
      path: /root/.ssh

# Update the Kubernetes deployment config.
- name: 'gcr.io/cloud-builders/gcloud'
  env:
    - 'KUBECONFIG=/kube/config'
  entrypoint: 'sh'
  args:
    - '-c'
    - |
      kubectl patch -f pipeline-infrastructure/staging/app.yaml -p \
        '{
           "spec": {
             "template": {
               "spec": {
                 "containers":[
                   {
                     "name": "helloworld",
                     "image": "gcr.io/hightowerlabs/pipeline-app:$COMMIT_SHA"
                   }
                 ]
               }
             }
           }
         }' \
        --local \
        -o yaml > pipeline-infrastructure/staging/app.yaml

      kubectl apply -f pipeline-infrastructure/staging/app.yaml
  volumes:
    - name: 'kube'
      path: /kube
